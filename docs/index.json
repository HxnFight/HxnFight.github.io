[
{
	"uri": "http://blog.valjean.cn/soul/env/",
	"title": "环境搭建",
	"tags": [],
	"description": "",
	"content": " 开篇随笔   自己的学习随笔和感想. 自己还没有做过这样正式的学习记录。\n 希望在这一个月的学习过程中，不断提升自己的能力。\n 进行开发环境、blog环境的搭建。\n 搞得还是有点仓促，只记录一下一些大致过程。\n 本来也有个国内ec2的环境，但是最近访问报网站未审核，\n 今天刚提了审核，可能得过几天才会下来。随后会迁移到自己的ec2上.\n 刚从manjaro 换到deepin系统上。有些软件还未安装完毕，先将就的用着\n 等周末将环境好好的整理一下\n  "
},
{
	"uri": "http://blog.valjean.cn/soul/exercise/",
	"title": "模块实践",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/",
	"title": "docs",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.valjean.cn/soul/exercise/dubbo/",
	"title": "Dubbo 模块实践",
	"tags": [],
	"description": "",
	"content": " dubbo模块  参考手册  官方:dubbo插件 官方:dubbo用户  文档说明很详细的,其中提到以下几个重点\n  dubbo 服务接入soul的配置\n  接入之后的调用方式, 参数传递方式. 全部是post请求 Content-Type: application/json格式.\n  将dubbo服务转成http形式, 感觉可以用在项目中,省去给dubbo服务搭建的空壳子api.\n    实际测试    偶尔发现idea自带的 http client,比之前有了很大的改善,可以支持将请求放在文本中. 具体的使用可以参考官方文档: idea tools http client  # dubbo 插件的要用post请求,请求类型为 Content-Type: application/json # 测试查询数据 POST http://localhost:9195/dubbo/findById Content-Type: application/json { \u0026#34;id\u0026#34;: \u0026#34;999\u0026#34; } # 测试保存数据 POST http://localhost:9195/dubbo/insert Content-Type: application/json { \u0026#34;id\u0026#34;: \u0026#34;999\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;valjean\u0026#34; }   Tip: 请求记录文件,可以直接导入idea中     dubbo-test.http  (0 )      遇到的问题    dubbo 启动之后报错 这个暂未定位到什么地方出错\njava.lang.IllegalStateException: No such application config! Please add \u0026lt;dubbo:application name=\u0026#34;...\u0026#34; /\u0026gt; to your spring config. at com.alibaba.dubbo.config.AbstractInterfaceConfig.checkApplication(AbstractInterfaceConfig.java:145) ~[dubbo-2.6.5.jar:2.6.5] at com.alibaba.dubbo.config.ReferenceConfig.init(ReferenceConfig.java:278) ~[dubbo-2.6.5.jar:2.6.5] at com.alibaba.dubbo.config.ReferenceConfig.get(ReferenceConfig.java:163) ~[dubbo-2.6.5.jar:2.6.5] at org.dromara.soul.plugin.alibaba.dubbo.cache.ApplicationConfigCache.build(ApplicationConfigCache.java:166) ~[classes/:na] at org.dromara.soul.plugin.alibaba.dubbo.cache.ApplicationConfigCache.initRef(ApplicationConfigCache.java:130) ~[classes/:na] at org.dromara.soul.plugin.alibaba.dubbo.subscriber.AlibabaDubboMetaDataSubscriber.onSubscribe(AlibabaDubboMetaDataSubscriber.java:43) ~[classes/:na]    soul-examples-dubbo 启动之后,访问显示的divide插件信息 需要在soul-admin中打开dubbo的插件开关 系统管理---\u0026gt; 插件管理 再个就是注意请求的数据类型,要个bean中定义的一致.\n#网关报错如下 can not match selector data: divide # 请求结果如下 { \u0026#34;code\u0026#34;: -107, \u0026#34;message\u0026#34;: \u0026#34;Can not find selector, please check your configuration!\u0026#34;, \u0026#34;data\u0026#34;: null }        手册回顾  再回顾官方文档的过程中,记录一下新的兴趣点\n  soul 配置规则学习 官方文档说明 其中最重要的三个概念: 插件 选择器 规则 一个插件对应多个选择器, 一个选择器对应多个规则 一个选择器对应多个匹配条件, 一个规则对应多个匹配条件 反应到表结构上,可以参考 数据库设计 ,后续会记录详细的配置使用记录\n  soul 插件 soul 目前的插件有十几种,其中自己感兴趣以及目前工作中能用到的有\n  divide   sign\n  rewrite\n  waf\n  monitor\n  会着重看一下的   如下几个功能点特感兴趣\n  soul-admin与soul网关数据同步的三种方式\n  soul-client对本地接口数据的收集实现\n  插件热插拔的实现机制\n      "
},
{
	"uri": "http://blog.valjean.cn/soul/exercise/http-divie/",
	"title": "divide 模块实践",
	"tags": [],
	"description": "",
	"content": " divide 模块  参考手册  在项目根目录下的doc\ndoc ├── user-http.md └── plugin-divide.md   通过这两个文档的介绍，针对http的调用，明白两件事。\n  会在自己的项目中引入soul依赖，并且配置相关的接口. 让soul代理自己的接口\n  会调用soul的接口, 会配置admin中divide插件\n    启动项目   启动没有什么特殊配置，idea下一键启动. 启动后注意下各个服务的端口号,soul默认的端口如下\n   server port comment     SoulAdminBootstrap 9095 管理后台   SoulBootstrapApplication 9195 网关   SoulTestHttpApplication 8188 测试项目     在用soul 代理http接口后，请求地址和端口需要换成网关的。\n接口的url也需要按照管理后台中的配置请求. 具体的请求，后面有样例.\n  测试请求    post 的请求方式   # 项目自身的请求 curl -s -H \u0026#34;Content-type: application/json\u0026#34; -d \u0026#39;@./param.json\u0026#39; -X POST localhost:8188//order/save | jq \u0026#39;.\u0026#39;n # soul 代理的请求 curl -s -H \u0026#34;Content-type: application/json\u0026#34; -d \u0026#39;@./param.json\u0026#39; -X POST localhost:9195/http/order/save | jq \u0026#39;.\u0026#39;n     get 的请求方式\n  # 项目自身的请求 curl -s localhost:8188/order/findById\\?id=1 | jq \u0026#39;.\u0026#39; # soul 代理的请求 curl -s localhost:9195/http/order/findById\\?id=1 | jq \u0026#39;.\u0026#39;     安利一下： jq 终端下处理json 文本、文件的瑞士军刀    总结   项目中使用到了webflux相关内容，这块之前没有接触过，周末会补充一下。\n通过项目中自带的docs、example-http.对soul的架构有了进一步的理解。\n 自己简要理解如下： . 后续会补充自己的认知流程图\n 官网的架构图如下:     "
},
{
	"uri": "http://blog.valjean.cn/soul/env/basic/",
	"title": "文档环境、代码环境",
	"tags": [],
	"description": "",
	"content": " hugo theme 选择    一直再找一个比较合适的blog生成工具. 最早的时候是自己编写markdown，上传到csdn中. 后来接触到vim emacs，使用emacs orgmode 自带的publish系统搭建了一套自己的wiki 也整合上传到了github中，不过后续更少更新。所有的学习笔记、工作笔记也都是记录再本地中基本都是组内人再访问。 随后也尝试过jekyll，但是都不太理想。直到前段时间接触、学习了hugo。感觉还是比较符合自己的需求。 目前简单修改了一个主题来使用 hugo-theme-learn, 改的比较糙。也在慢慢的优化使用. 还有就是这个排版，也好头疼。等我再搞搞的\n    github pages 设置    早期在github page中搭建blog是建立一个\u0026lt;USERNAME\u0026gt;.github.io项目。 将编译后的静态内容作为内容提交。   这几天在查看hugo的发布时，发现在可以在github.io项目中，建立一个docs的文件夹，来存放 生成的静态网站内容，这样方便和源码存放。\n    soul 代码编译    下载代码\ngit clone https://github.com/dromara/soul.git    编译代码 shardingshpere 中也是采用这样的命令。 其中rat checkstyle 有空看看的，自己的项目中没有使用过.\nmvn clean package install -Dmaven.test.skip=true -Dmaven.javadoc.skip=true -Drat.skip=true -Dcheckstyle.skip=true    deepin install docker tutor\nsudo apt-get remove -y docker docker-engine docker.io containerd runc sudo apt-get install -y apt-transport-https ca-certificates curl gnupg2 software-properties-common curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - sudo apt-key fingerprint 0EBFCD88 # 主要是这句，官方文档中，执行类似的这句报错 # https://docs.docker.com/engine/install/ubuntu/ #sudo add-apt-repository \\ # \u0026#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ # $(lsb_release -cs) \\ # stable\u0026#34; printf \u0026#39;deb [arch=amd64] https://download.docker.com/linux/debian stretch stable\\n\u0026#39; | sudo tee /etc/apt/sources.list.d/docker-ce.list sudo apt-get update -y sudo apt-get install -y docker-ce sudo usermod -aG docker $(whoami)    docker install mysql\ndocker run --rm -d --name local_mysql \\ -v /data/docker/mysql/:/var/lib/mysql \\ -p 3306:3306 -e MYSQL_ROOT_PASSWORD=xxxxxxx mysql:5.7.32    docker install zk\ndocker run -d --rm \\ -p 2181:2181 -p 2888:2888 -p 3888:3888 -p 8080:8080 \\ --name local-zk \\ -v /tmp/log/zk:/logs/ \\ -e ZOO_LOG4J_PROP=\u0026#34;INFO,ROLLINGFILE\u0026#34; \\ zookeeper    soul-admin 启动\n mysql 安装以后，修改soul-admin配置文件application-local.yml 中的db密码，就可以编译启动 db 相关文件soul会自动创建\n     环境待改善的地方    emacs emacs 中配置spacemacs, 家里下载spacemacs比较慢。 emacs 排版问题\n  vim vim 中 YouCompleteMe插件的编译安装 vim本身配置的调试\n  deepin 开机中加入一些自启动项\n  hugo 安装的版本过低，渲染org文件失败，折腾半天，升级最近的版本后 支持渲染org文件,这点疏忽了，公司环境安装的比较新。\n  rat checkstyle 查一些资料\n    "
},
{
	"uri": "http://blog.valjean.cn/",
	"title": "soul 学习笔记",
	"tags": [],
	"description": "",
	"content": " soul 学习笔记    官方文档\n    "
},
{
	"uri": "http://blog.valjean.cn/soul/",
	"title": "soul 学习笔记",
	"tags": [],
	"description": "",
	"content": " 开篇   "
},
{
	"uri": "http://blog.valjean.cn/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/plugin-divide/",
	"title": "divide插件",
	"tags": [],
	"description": "divide插件",
	"content": "说明  divide插件是网关处理 http协议请求的核心处理插件。  插件设置   开启插件, soul-admin \u0026ndash;\u0026gt; 插件管理\u0026ndash;\u0026gt; divide 设置为启用。\n  divide插件，配合如下 starter一起才能生效，具体请看：http用户。\n  \u0026lt;!--if you use http proxy start this--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-divide\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 插件讲解   divide插件是进行http正向代理的插件，所有http类型的请求，都是由该插件进行负载均衡的调用。\n  选择器和规则，请详细看 : 选择器规则。\n  http配置，是网关匹配到流量以后，真实调用的http配置，可以配置多个，设置负载均衡权重，具体的负载均衡策略，在规则中指定。\n  配置详解 ：\n  第一个框：hostName，一般填写 localhost，该字段暂时没使用。\n  第二个框：http协议，一般填写 http:// 或者 https:// ,不填写默认为:http://\n  第三个框：ip与端口，这里填写你真实服务的 ip + 端口。\n  第四个框：负载均衡权重。\n    ip + port 检测\n  在soul-admin 会有一个定时任务来扫描 配置的ip端口，如果发现下线，则会除该 ip + port\n  可以进行如下配置 ：\n      soul.upstream.check:true 默认为 ture，设置为false，不检测 soul.upstream.scheduledTime:10 定时检测时间间隔，默认10秒 "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/user-dubbo/",
	"title": "dubbo接入soul网关",
	"tags": [],
	"description": "dubbo接入soul网关",
	"content": "说明   此篇文章是dubbo用户使用dubbo插件支持，以及自己的dubbo服务接入soul网关的教程。\n  支持 alibaba dubbo（\u0026lt; 2.7.x） 以及 apache dubbo (\u0026gt;=2.7.x)。\n  接入前，请正确的启动 soul-admin , 以及搭建环境 Ok。\n  引入网关对dubbo支持的插件   在网关的 pom.xml 文件中增加如下依赖：\n alibaba dubbo 用户, dubbo版本换成你的，注册中心的jar包换成你的，一下是参考。    \u0026lt;!--soul alibaba dubbo plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-alibaba-dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- soul alibaba dubbo plugin end--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.curator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;curator-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.curator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;curator-framework\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.curator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;curator-recipes\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  apache dubbo 用户，dubbo版本换成你的，使用什么注册中心换成你的,以下是参考,使用什么注册中心，就引入啥。  \u0026lt;!--soul apache dubbo plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-apache-dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--soul apache dubbo plugin end--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.dubbo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Dubbo Nacos registry dependency start --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.dubbo\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dubbo-registry-nacos\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.nacos\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;nacos-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Dubbo Nacos registry dependency end--\u0026gt; \u0026lt;!-- Dubbo zookeeper registry dependency start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.curator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;curator-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.curator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;curator-framework\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.curator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;curator-recipes\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Dubbo zookeeper registry dependency end --\u0026gt;  重启网关服务。  dubbo服务接入网关,可以参考 : soul-test-dubbo   alibaba dubbo 用户\n  springboot\n 引入以下依赖      \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-client-alibaba-dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  在你的yml文件中新增如下配置 ：  soul: dubbo: adminUrl: http://localhost:9095 contextPath: /dubbo appName: dubbo  # adminUrl: 为你启动的soul-admin 项目的ip + 端口，注意要加 http:// # contextPath: 为你的这个项目在soul网关的路由前缀，这个你应该懂意思把？ 比如/order ，/product 等等，网关会根据你的这个前缀来进行路由. # appName：你的应用名称，不配置的话，会默认取 dubbo配置中application 中的名称   spring\n 引入以下依赖 ：    \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-client-alibaba-dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  在你的 bean定义的xml文件中新增如下 ：  \u0026lt;bean id =\u0026#34;alibabaDubboServiceBeanPostProcessor\u0026#34; ,class =\u0026#34;org.dromara.soul.client.alibaba.dubbo.AlibabaDubboServiceBeanPostProcessor\u0026#34;\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;dubboConfig\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dubboConfig\u0026#34;, class=\u0026#34;org.dromara.soul.client.dubbo.common.config.DubboConfig\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;adminUrl\u0026#34; value=\u0026#34;http://localhost:9095\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;contextPath\u0026#34; value=\u0026#34;/你的contextPath\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;appName\u0026#34; value=\u0026#34;你的名字\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   apache dubbo 用户\n  springboot\n 引入以下依赖      \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-client-apache-dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  在你的yml文件中新增如下配置 ：  soul: dubbo: adminUrl: http://localhost:9095 contextPath: /dubbo appName: dubbo # adminUrl: 为你启动的soul-admin 项目的ip + 端口，注意要加 http:// # contextPath: 为你的这个项目在soul网关的路由前缀，这个你应该懂意思把？ 比如/order ，/product 等等，网关会根据你的这个前缀来进行路由. # appName：你的应用名称，不配置的话，会默认取 dubbo配置中application 中的名称   spring\n 引入以下依赖 ：  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-client-apache-dubbo\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   在你的 bean定义的xml文件中新增如下 ：\n  \u0026lt;bean id =\u0026#34;apacheDubboServiceBeanPostProcessor\u0026#34; ,class =\u0026#34;org.dromara.soul.client.apache.dubbo.ApacheDubboServiceBeanPostProcessor\u0026#34;\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;dubboConfig\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dubboConfig\u0026#34;, class=\u0026#34;org.dromara.soul.client.dubbo.common.config.DubboConfig\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;adminUrl\u0026#34; value=\u0026#34;http://localhost:9095\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;contextPath\u0026#34; value=\u0026#34;/你的contextPath\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;appName\u0026#34; value=\u0026#34;你的名字\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; dubbo 插件设置   首先在 soul-admin 插件管理中，把dubbo 插件设置为开启。\n  其次在 dubbo  插件中配置你的注册地址,或者其他注册中心的地址.\n  {\u0026#34;register\u0026#34;:\u0026#34;zookeeper://localhost:2181\u0026#34;} or {\u0026#34;register\u0026#34;:\u0026#34;nacos://localhost:8848\u0026#34;} 接口注册到网关   你dubbo服务实现类的，方法上加上 @SoulDubboClient 注解，表示该接口方法注册到网关。\n  启动你的提供者,输出日志 dubbo client register success  大功告成，你的dubbo接口已经发布到 soul网关.如果还有不懂的，可以参考 soul-test-dubbo项目.\n  dubbo用户请求以及参数说明   说白了，就是通过http的方式来请求你的dubbo服务\n  soul网关需要有一个路由前缀，这个路由前缀就是你接入项目进行配置 contextPath\n  # 比如你有一个 order服务 它有一个接口，它的注册路径 /order/test/save # 现在就是通过 post方式请求网关：http://localhost:9195/order/test/save # 其中 localhost:9195 为网关的ip端口，默认端口是9195 ，/order 是你dubbo接入网关配置的 contextPath   参数传递：\n  通过 http post 方式访问网关，通过body，json类型传递。\n  更多参数类型传递，可以参考 soul-test-dubbo 中的接口定义，以及参数传递方式。\n    单个java bean参数类型 （默认）\n  多参数类型支持 ,在网关的yaml 配置中新增如下配置：\n  soul : dubbo : parameter: multi   自定义实现多参数支持:\n 在你搭建的网关项目中，新增一个类 A，实现 org.dromara.soul.web.dubbo.DubboParamResolveService。    public interface DubboParamResolveService { /** * Build parameter pair. * this is Resolve http body to get dubbo param. * * @param body the body * @param parameterTypes the parameter types * @return the pair */ Pair\u0026lt;String[], Object[]\u0026gt; buildParameter(String body, String parameterTypes); }   body为http中body传的json字符串.\n  parameterTypes: 匹配到的方法参数类型列表，如果有多个,则使用,分割。\n  Pair中，left为参数类型，right为参数值，这是dubbo泛化调用的标准\n  把你的类注册成Spring的bean，覆盖默认的实现。\n  @Bean public DubboParamResolveService A() { return new A(); } 大白话讲解如果通过http \u0026ndash;\u0026gt; 网关\u0026ndash;\u0026gt; dubbo provider   说白了，就是把http请求，转成dubbo协议，内部使用dubbo泛化来进行调用。\n  首先你要回想下，你的dubbo服务在接入网关的时候，是不是加了个 @SoulDubboClient 注解，里面是不是有个path字段来指定你请求的路径？\n  你是不是还在yml中配置了一个 contextPath?\n  如果您还记得，那我们就开始。\n  假如你有一个这样的方法, contextPath 配置的是 /dubbo\n  @Override @@SoulDubboClient(path = \u0026#34;/insert\u0026#34;, desc = \u0026#34;插入一条数据\u0026#34;) public DubboTest insert(final DubboTest dubboTest) { return dubboTest; }   那么我们请求的路径为: http://localhost:9195/dubbo/insert ,再说一下，localhost:9195是网关的域名，如果你更改了，这里也要改。\n  那么请求参数呢？ DubboTest 是一个javabean对象，有2个字段，id与name ，那么我们通过body中传递这个对象的json数据就好。\n  {\u0026quot;id\u0026quot;:\u0026quot;1234\u0026quot;,\u0026quot;name\u0026quot;:\u0026quot;XIAO5y\u0026quot;}  如果你的接口中,没有参数，那么body传值为:  {}  如果你的接口有很多个参数? 往上看一点，有介绍。  "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/plugin-dubbo/",
	"title": "dubbo插件",
	"tags": [],
	"description": "dubbo插件",
	"content": "说明   dubbo插件是将http协议 转换成dubbo协议 的插件,也是网关实现dubbo泛化调用的关键。\n  dubbo插件需要配合元数据才能实现dubbo的调用，具体请看: 元数据。\n  apache dubbo 和 alibaba dubbo用户，都是使用该同一插件。\n  插件设置   在 soul-admin \u0026ndash;\u0026gt; 插件管理-\u0026gt; dubbo 设置为开启。\n  在dubbo插件的配置中，配置如下: 配置dubbo的注册中心。\n  {\u0026#34;register\u0026#34;:\u0026#34;zookeeper://localhost:2181\u0026#34;} or {\u0026#34;register\u0026#34;:\u0026#34;nacos://localhost:8848\u0026#34;}    插件需要配合依赖 starter 进行使用,具体请看: dubbo用户。\n  选择器和规则，请详细看 : 选择器规则。\n  元数据   每一个dubbo接口方法，都会对于一条元数据，可以在 soul-admin \u0026ndash;\u0026gt;元数据管理，进行查看。\n  路径：就是你http请求的路径。\n  rpc扩展参数,对应为dubbo接口的一些配置，调整的化，请在这里修改，支持json格式,以下字段：\n  {\u0026#34;timeout\u0026#34;:10000,\u0026#34;group\u0026#34;:\u0026#34;\u0026#34;,version\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;loadbalance\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;retries\u0026#34;:1,\u0026#34;url\u0026#34;:\u0026#34;\u0026#34;} "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/dev-filter/",
	"title": "filter扩展",
	"tags": [],
	"description": "filter扩展",
	"content": "说明  本文是说明,如何进行 org.springframework.web.server.WebFliter 的扩展。  跨域支持  新增 org.dromara.soul.bootstrap.cors.CrossFilter 实现 WebFilter。  public class CrossFilter implements WebFilter { private static final String ALLOWED_HEADERS = \u0026#34;x-requested-with, authorization, Content-Type, Authorization, credential, X-XSRF-TOKEN,token,username,client\u0026#34;; private static final String ALLOWED_METHODS = \u0026#34;*\u0026#34;; private static final String ALLOWED_ORIGIN = \u0026#34;*\u0026#34;; private static final String ALLOWED_EXPOSE = \u0026#34;*\u0026#34;; private static final String MAX_AGE = \u0026#34;18000\u0026#34;; @Override @SuppressWarnings(\u0026#34;all\u0026#34;) public Mono\u0026lt;Void\u0026gt; filter(final ServerWebExchange exchange, final WebFilterChain chain) { ServerHttpRequest request = exchange.getRequest(); if (CorsUtils.isCorsRequest(request)) { ServerHttpResponse response = exchange.getResponse(); HttpHeaders headers = response.getHeaders(); headers.add(\u0026#34;Access-Control-Allow-Origin\u0026#34;, ALLOWED_ORIGIN); headers.add(\u0026#34;Access-Control-Allow-Methods\u0026#34;, ALLOWED_METHODS); headers.add(\u0026#34;Access-Control-Max-Age\u0026#34;, MAX_AGE); headers.add(\u0026#34;Access-Control-Allow-Headers\u0026#34;, ALLOWED_HEADERS); headers.add(\u0026#34;Access-Control-Expose-Headers\u0026#34;, ALLOWED_EXPOSE); headers.add(\u0026#34;Access-Control-Allow-Credentials\u0026#34;, \u0026#34;true\u0026#34;); if (request.getMethod() == HttpMethod.OPTIONS) { response.setStatusCode(HttpStatus.OK); return Mono.empty(); } } return chain.filter(exchange); } }  将 CrossFilter 注册成为 spring的bean,完事.  网关过滤 springboot健康检查  注意顺序，使用 @Order 注解  @Component @Order(-99) public final class HealthFilter implements WebFilter { private static final String[] FILTER_TAG = {\u0026#34;/actuator/health\u0026#34;, \u0026#34;/health_check\u0026#34;}; @Override public Mono\u0026lt;Void\u0026gt; filter(@Nullable final ServerWebExchange exchange, @Nullable final WebFilterChain chain) { ServerHttpRequest request = Objects.requireNonNull(exchange).getRequest(); String urlPath = request.getURI().getPath(); for (String check : FILTER_TAG) { if (check.equals(urlPath)) { String result = JsonUtils.toJson(new Health.Builder().up().build()); DataBuffer dataBuffer = exchange.getResponse().bufferFactory().wrap(result.getBytes()); return exchange.getResponse().writeWith(Mono.just(dataBuffer)); } } return Objects.requireNonNull(chain).filter(exchange); } } 继承 org.dromara.soul.web.filter.AbstractWebFilter   新增一个类，继承它。\n  实现它的2个方法。\n  /** * this is Template Method ,children Implement your own filtering logic. * * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026lt;Boolean\u0026gt;} result：TRUE (is pass)，and flow next filter；FALSE (is not pass) execute doDenyResponse(ServerWebExchange exchange) */ protected abstract Mono\u0026lt;Boolean\u0026gt; doFilter(ServerWebExchange exchange, WebFilterChain chain); /** * this is Template Method ,children Implement your own And response client. * * @param exchange the current server exchange. * @return {@code Mono\u0026lt;Void\u0026gt;} response msg. */ protected abstract Mono\u0026lt;Void\u0026gt; doDenyResponse(ServerWebExchange exchange);  doFilter 方法返回 Mono表示通过,反之则不通过，不通过的时候，会调用 doDenyResponse,输出相关信息到前端。  "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/user-http/",
	"title": "http用户",
	"tags": [],
	"description": "http用户",
	"content": "说明   本文旨在帮助http用户。\n  soul网关使用 divide 插件来处理http请求。请求在soul-admin后台开启它。\n  接入前，请正确的启动 soul-admin , 以及 搭建环境 OK。\n  引入网关对http的代理插件  在网关的 pom.xml 文件中增加如下依赖：  \u0026lt;!--if you use http proxy start this--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-divide\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  当然是要重新启动网关。  Http请求接入网关（springMvc体系用户）  首先要确保在 soul-admin 后台 divide插件是否开启。  Soul-Client接入方式。 （此方式针对SpringMvc,SpringBoot用户）   SpringBoot用户\n 在你的真实服务的 pom.xml 新增如下依赖:    \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-client-springmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  在yml中新增如下配置 ：  soul: http: adminUrl: http://localhost:9095 port: 你本项目的启动端口 contextPath: /http appName: http full: false # adminUrl: 为你启动的soul-admin 项目的ip + 端口，注意要加http:// # port: 你本项目的启动端口 # contextPath: 为你的这个mvc项目在soul网关的路由前缀，这个你应该懂意思把？ 比如/order ，/product 等等，网关会根据你的这个前缀来进行路由. # appName：你的应用名称，不配置的话，会默认取 `spring.application.name` 的值 # full: 设置true 代表代理你的整个服务，false表示代理你其中某几个controller  SpringMvc用户  在你的真实服务的 pom.xml 新增如下依赖:    \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-client-springmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  在你的 bean定义的xml文件中新增如下 ：  \u0026lt;bean id =\u0026#34;springMvcClientBeanPostProcessor\u0026#34; ,class =\u0026#34;org.dromara.soul.client.springmvc.init.SpringMvcClientBeanPostProcessor\u0026#34;\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;soulSpringMvcConfig\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;soulSpringMvcConfig\u0026#34;, class=\u0026#34;org.dromara.soul.client.springmvc.config.SoulSpringMvcConfig\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;adminUrl\u0026#34; value=\u0026#34;http://localhost:9095\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;port\u0026#34; value=\u0026#34;你的端口\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;contextPath\u0026#34; value=\u0026#34;/你的contextPath\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;appName\u0026#34; value=\u0026#34;你的名字\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;full\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt;   在你的 controller 的接口上加上 @SoulSpringMvcClient 注解。\n  你可以把注解加到 Controller 类上面, 里面的path属性则为前缀，如果含有 /** 代表你的整个接口需要被网关代理。\n  举列子 （1）： 代表 /test/payment, /test/findByUserId 都会被网关代理。\n    @RestController @RequestMapping(\u0026#34;/test\u0026#34;) @SoulSpringMvcClient(path = \u0026#34;/test/**\u0026#34;) public class HttpTestController { @PostMapping(\u0026#34;/payment\u0026#34;) public UserDTO post(@RequestBody final UserDTO userDTO) { return userDTO; } @GetMapping(\u0026#34;/findByUserId\u0026#34;) public UserDTO findByUserId(@RequestParam(\u0026#34;userId\u0026#34;) final String userId) { UserDTO userDTO = new UserDTO(); userDTO.setUserId(userId); userDTO.setUserName(\u0026#34;hello world\u0026#34;); return userDTO; } }  举列子 （2）： 代表 /order/save,会被网关代理,而/order/findById 则不会。  @RestController @RequestMapping(\u0026#34;/order\u0026#34;) @SoulSpringMvcClient(path = \u0026#34;/order\u0026#34;) public class OrderController { @PostMapping(\u0026#34;/save\u0026#34;) @SoulSpringMvcClient(path = \u0026#34;/save\u0026#34;) public OrderDTO save(@RequestBody final OrderDTO orderDTO) { orderDTO.setName(\u0026#34;hello world save order\u0026#34;); return orderDTO; } @GetMapping(\u0026#34;/findById\u0026#34;) public OrderDTO findById(@RequestParam(\u0026#34;id\u0026#34;) final String id) { OrderDTO orderDTO = new OrderDTO(); orderDTO.setId(id); orderDTO.setName(\u0026#34;hello world findById\u0026#34;); return orderDTO; } }  启动你的项目，你的接口接入到了网关。  Http请求接入网关（其他语言，非springMvc体系）   首先在 soul-admin 找到 divide插件，进行选择器，和规则的添加，进行流量的匹配筛选。\n  如果不懂怎么配置，请看选择，规则介绍 选择器规则介绍。\n  您也可以自定义开发属于你的 http-client，参考 多语言Http客户端开发。\n  用户请求   说白了，你之前怎么请求就怎么请求，没有很大的变动，变动的地方有2点。\n  第一点，你之前请求的域名是你自己的服务，现在要换成网关的域名 （这个你听的懂？）\n  第二点，soul网关需要有一个路由前缀，这个路由前缀就是你接入项目进行配置 contextPath ,如果熟的话，可以自由在 soul-admin 中的divide插件进行自由更改.\n  # 比如你有一个 order服务 它有一个接口，请求路径 http://localhost:8080/test/save # 现在就需要换成：http://localhost:9195/order/test/save # 其中 localhost:9195 为网关的ip端口，默认端口是9195 ，/order 是你接入网关配置的 contextPath # 其他参数，请求方式不变。 # 我讲到这里还不懂？ 请加群问吧  然后你就可以进行访问了，如此的方便与简单。  "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/plugin-hystrix/",
	"title": "hystrix插件",
	"tags": [],
	"description": "hystrix插件",
	"content": "说明   hystrix插件是网关用来对流量进行熔断的核心实现。\n  使用信号量的方式来处理请求。\n  插件设置   在 soul-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; hystrix ,设置为开启。\n  如果用户不使用，则在 soul-admin 后台把此插件停用。\n  插件使用  在网关的 pom.xml 文件中添加 hystrix的支持。  \u0026lt;!-- soul hystrix plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- soul hystrix plugin end--\u0026gt;   选择器和规则，请详细看 : 选择器规则\n  Hystrix处理详解：\n  跳闸最小请求数量 ：最小的请求量，至少要达到这个量才会触发熔断\n  错误半分比阀值 ： 这段时间内，发生异常的百分比。\n  最大并发量 ： 最大的并发量\n  跳闸休眠时间(ms) ：熔断以后恢复的时间。\n  分组Key： 一般设置为:contextPath\n  命令Key: 一般设置为具体的 路径接口。\n    "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/plugin-monitor/",
	"title": "monitor插件",
	"tags": [],
	"description": "monitor插件",
	"content": "说明  monitor插件是网关用来监控自身运行状态（JVM相关），请求的响应迟延，QPS,TPS等相关metrics。  技术方案   流程图   异步或者同步的方式，在soul网关里面进行 metrics 埋点。\n  prometheus 服务端通过 http 请求 来 拉取 metrics, 再使用 Grafana  展示。\n  插件设置   在 soul-admin\u0026ndash;\u0026gt; 插件管理-\u0026gt; monitor ,设置为开启。\n  在 monitor 插件中新增以下配置\n  {\u0026#34;metricsName\u0026#34;:\u0026#34;prometheus\u0026#34;,\u0026#34;host\u0026#34;:\u0026#34;localhost\u0026#34;,\u0026#34;port\u0026#34;:\u0026#34;9191\u0026#34;,\u0026#34;async\u0026#34;:\u0026#34;true\u0026#34;} # port : 为暴露给 prometheus服务来拉取的端口 # host : 不填写则为soul网关的host. # async :\u0026#34;true\u0026#34; 为异步埋点， false 为同步埋点  如果用户不使用，则在 soul-admin 后台把此插件停用.  插件使用  在网关的 pom.xml 文件中添加 monitor 的支持。  \u0026lt;!-- soul monitor plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-monitor\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- soul monitor plugin end--\u0026gt;   选择器和规则，请详细看 : 选择器规则。\n 只有当匹配的url，才会进行url请求埋点。    metrics信息   所有的JVM，线程，内存，等相关信息都会埋点，可以在 Granfana  面板中，新增一个 JVM 模块，则会完全展示 具体请看 ： https://github.com/prometheus/jmx_exporter\n  另外还有如下自定义的 metrics\n     名称 类型 标签名称 说明     request_total Counter 无 收集Soul网关所有的请求   http_request_total Counter path,type 收集monitor插件匹配的请求    收集 metrics  用户自己搭建Prometheus 服务，在 prometheus.yml 文件中新增如下配置:  scrape_configs: # The job name is added as a label `job=\u0026lt;job_name\u0026gt;` to any timeseries scraped from this config. - job_name: \u0026#39;shardingSphere-proxy\u0026#39; # metrics_path defaults to \u0026#39;/metrics\u0026#39; # scheme defaults to \u0026#39;http\u0026#39;. static_configs: - targets: [\u0026#39;localhost:9191\u0026#39;] 面板展示 推荐使用 Granfana，用户可以自定义查询来个性化显示面板盘，后续我会提供默认的面板盘配置。\n"
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/plugin-ratelimiter/",
	"title": "rateLimiter插件",
	"tags": [],
	"description": "rateLimiter插件",
	"content": "说明   限流插件，是网关对流量管控限制核心的实现。\n  可以到接口级别，也可以到参数级别，具体怎么用，还得看你对流量配置。\n  技术方案   采用redis令牌桶算法进行限流。\n  流程图：   插件设置   在 soul-admin\u0026ndash;\u0026gt; 插件管理\u0026ndash;\u0026gt; rate_limiter 将其设置为开启。\n  在插件中，对redis进行配置。\n  目前支持redis的单机，哨兵，以及集群模式。\n  如果是哨兵，集群等多节点的，在URL中的配置，请对每个实列使用 ; 分割. 如 192.168.1.1:6379;192.168.1.2:6379。\n  如果用户无需使用，在admin后台把插件禁用。\n  插件使用  在网关的 pom.xml 文件中添加 rateLimiter的支持。  \u0026lt;!-- soul ratelimiter plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-ratelimiter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- soul ratelimiter plugin end--\u0026gt;   选择器和规则，请详细看 : 选择器规则。\n  速率：是你允许用户每秒执行多少请求，而丢弃任何请求。这是令牌桶的填充速率。\n  容量 ：是允许用户在一秒钟内执行的最大请求数。这是令牌桶可以保存的令牌数。\n  "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/plugin-rewrite/",
	"title": "rewrite插件",
	"tags": [],
	"description": "rewrite插件",
	"content": "说明  soul网关在对目标服务进行代理调用的时候，还容许用户使用 rewrite 插件来重写请求路径  插件设置   在 soul-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; rewrite ,设置为开启。\n  在网关的 pom.xml 文件中添加 rewrite 的支持。\n  如果用户不需要，可以把插件禁用。\n  \u0026lt;!-- soul rewrite plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-rewrite\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- soul rewrite plugin end--\u0026gt;   选择器和规则，请详细看 : 选择器规则。\n 只有匹配的请求，才会进行重写。    场景   顾名思义，重新插件就是对uri的重新定义。\n  当匹配到请求后，设置自定义的路径，那么自定义的路径就会覆盖之前的真实路径。\n  在调用的时候，就会使用用户自定义的路径。\n  "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/plugin-sign/",
	"title": "sign插件",
	"tags": [],
	"description": "sign插件",
	"content": "说明  sign插件是 soul网关自带的，用来对请求进行签名认证的插件。  插件设置  在 soul-admin -\u0026gt; 插件管理中 \u0026ndash;\u0026gt; sign插件设置为开启。  插件使用  在网关的 pom.xml 文件中添加 sign 的支持。  \u0026lt;!-- soul sign plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-sign\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- soul sign plugin end--\u0026gt;   选择器和规则，请详细看 : 选择器规则。\n 只有匹配的请求，才会进行签名认证。    新增 AK/SK  在soul-admin \u0026ndash;\u0026gt; 认证管理中，点击新增，新增一条 AK/SK。  网关技术实现  采用Ak/SK鉴权技术方案。 采用鉴权插件，责任链的模式的模式来完成。 当鉴权插件开启，并配置所有接口鉴权时候生效。  鉴权使用指南   第一步：AK/SK由网关来进行分配. 比如分配给你的AK为: 1TEST123456781 SK为：506EEB535CF740D7A755CB4B9F4A1536\n  第一步：确定好你要访问的网关路径 比如 /api/service/abc\n  第三步:构造参数（以下是通用参数）\n     字段 值 描述     timestamp 当前时间戳(String类型) 当前时间的毫秒数（网关会过滤掉5分钟之前的请求）   path /api/service/abc 就是你需要访问的接口路径(根据你访问网关接口自己变更)   version 1.0.0 目前定位1.0.0 写死，String类型    对上述2个字段进行key的自然排序，然后进行字段与字段值拼接最后再拼接上SK,代码示例。\n第一步:首先构造一个Map。\nMap\u0026lt;String, String\u0026gt; map = Maps.newHashMapWithExpectedSize(2); //timestamp为毫秒数的字符串形式 String.valueOf(LocalDateTime.now().toInstant(ZoneOffset.of(\u0026#34;+8\u0026#34;)).toEpochMilli())  map.put(\u0026#34;timestamp\u0026#34;,\u0026#34;1571711067186\u0026#34;); //值应该为毫秒数的字符串形式  map.put(\u0026#34;path\u0026#34;, \u0026#34;/api/service/abc\u0026#34;); map.put(\u0026#34;version\u0026#34;, \u0026#34;1.0.0\u0026#34;); 第二步:进行Key的自然排序，然后Key，Value值拼接最后再拼接分配给你的Sk。\nList\u0026lt;String\u0026gt; storedKeys = Arrays.stream(map.keySet() .toArray(new String[]{})) .sorted(Comparator.naturalOrder()) .collect(Collectors.toList()); final String sign = storedKeys.stream() .map(key -\u0026gt; String.join(\u0026#34;\u0026#34;, key, params.get(key))) .collect(Collectors.joining()).trim() .concat(\u0026#34;506EEB535CF740D7A755CB4B9F4A1536\u0026#34;);  你得到的sign值应该为:path/api/service/abctimestamp1571711067186version1.0.0506EEB535CF740D7A755CB4B9F4A1536  第三步:进行Md5加密后转成大写。\nDigestUtils.md5DigestAsHex(sign.getBytes()).toUpperCase()  最后得到的值为:A021BF82BE342668B78CD9ADE593D683  请求网关   假如你访问的路径为 :/api/service/abc。\n  访问地址 ：http:网关的域名/api/service/abc。\n  设置header头，header头参数为：\n     字段 值 描述     timestamp 1571711067186 上述你进行签名的时候使用的时间值   appKey 1TEST123456781 分配给你的Ak值   sign A90E66763793BDBC817CF3B52AAAC041 上述得到的签名值   version 1.0.0 写死，就为这个值     签名插件会默认过滤5分钟之后的请求  如果认证不通过会返回 code 为401 message可能会有变动。 \u0026#34;code\u0026#34;:401,\u0026#34;message\u0026#34;:\u0026#34;sign is not pass,Please check you sign algorithm!\u0026#34;,\u0026#34;data\u0026#34;:null} 签名认证算法扩展  请参考开发者文档中的 扩展签名算法。  "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/soul/",
	"title": "soul介绍",
	"tags": [],
	"description": "soul介绍",
	"content": "What is the Soul？ 这是一个异步的,高性能的,跨语言的,响应式的API网关。我希望能够有一样东西像灵魂一样，保护您的微服务。参考了Kong，Spring-Cloud-Gateway等优秀的网关后，站在巨人的肩膀上，Soul由此诞生！\nFeatures   支持各种语言(http协议)，支持 dubbo，springcloud协议。\n  插件化设计思想，插件热插拔,易扩展。\n  灵活的流量筛选，能满足各种流量控制。\n  内置丰富的插件支持，鉴权，限流，熔断，防火墙等等。\n  流量配置动态化，性能极高，网关消耗在 1~2ms。\n  支持集群部署，支持 A/B Test, 蓝绿发布。\n  架构图 Prerequisite   JDK 1.8+   Maven 3.2.x   Git   mysql   "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/dev-netty/",
	"title": "soul性能优化",
	"tags": [],
	"description": "soul性能优化",
	"content": "说明  本文主要介绍如果对soul进行优化  本身消耗  soul本身所有的操作，都是基于jvm内存来匹配，本身消耗时间大概在 1-3 ms左右。  底层netty调优   soul内置依赖 spring-webflux 而其底层是使用的netty。这一块只要是使用的netty线程模型。\n  我们可以自定义netty的相关参数来对soul 进行优化,以下是示例：\n  @Bean public NettyReactiveWebServerFactory nettyReactiveWebServerFactory() { NettyReactiveWebServerFactory webServerFactory = new NettyReactiveWebServerFactory(); webServerFactory.addServerCustomizers(new EventLoopNettyCustomizer()); return webServerFactory; } private static class EventLoopNettyCustomizer implements NettyServerCustomizer { @Override public HttpServer apply(final HttpServer httpServer) { return httpServer .tcpConfiguration(tcpServer -\u0026gt; tcpServer .runOn(LoopResources.create(\u0026#34;soul-netty\u0026#34;, 1, DEFAULT_IO_WORKER_COUNT, true), false) .selectorOption(ChannelOption.SO_REUSEADDR, true) .selectorOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) .option(ChannelOption.TCP_NODELAY, true) .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)); } }   这个类在 soul-bootstrap中已经内置，在压测的时候，可以根据自己的需求来进行优化设置。\n  业务线程模型可以看线程模型\n  "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/user-springcloud/",
	"title": "springCloud接入soul网关",
	"tags": [],
	"description": "springCloud接入soul网关",
	"content": "说明   此篇文章是教你如何将springCloud接口，快速接入到soul网关。\n  请在 soul-admin 后台将 springCloud 插件设置为开启。\n  接入前，请正确的启动 soul-admin , 以及搭建环境 Ok。\n  引入网关 springCloud的插件支持  在网关的 pom.xml 文件中引入如下依赖。  \u0026lt;!--soul springCloud plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--soul springCloud plugin end--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-commons\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   如果你使用 eureka 作为 springCloud的注册中心\n 新增如下依赖：    \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  在网关的yml文件中 新增如下配置:  eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ # 你的eureka地址 instance: prefer-ip-address: true   如果你使用 nacos 作为 springCloud的注册中心\n 新增如下依赖：    \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.0.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  在网关的yml文件中 新增如下配置:  spring: cloud: nacos: discovery: server-addr: 127.0.0.1:8848 # 你的nacos地址  重启你的网关服务。  SpringCloud服务接入网关。  在你提供服务的项目中,引入如下依赖：  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-client-springcloud\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  在你的yml文件中新增如下配置:  soul: springcloud: admin-url: http://localhost:9095 context-path: /springcloud appName: http # adminUrl: 为你启动的soul-admin 项目的ip + 端口，注意要加http:// # contextPath: 为你的这个mvc项目在soul网关的路由前缀，这个你应该懂意思把？ 比如/order ，/product 等等，网关会根据你的这个前缀来进行路由. # appName：你的应用名称，不配置的话，会默认取 `spring.application.name` 的值   在你的 controller的接口上加上 @SoulSpringCloudClient 注解\n  你可以把注解加到 Controller 类上面, 里面的path属性则为前缀，如果含有 /** 代表你的整个接口需要被网关代理\n 举列子 （1）： 代表 /test/payment, /test/findByUserId 都会被网关代理。    @RestController @RequestMapping(\u0026#34;/test\u0026#34;) @SoulSpringCloudClient(path = \u0026#34;/test/**\u0026#34;) public class HttpTestController { @PostMapping(\u0026#34;/payment\u0026#34;) public UserDTO post(@RequestBody final UserDTO userDTO) { return userDTO; } @GetMapping(\u0026#34;/findByUserId\u0026#34;) public UserDTO findByUserId(@RequestParam(\u0026#34;userId\u0026#34;) final String userId) { UserDTO userDTO = new UserDTO(); userDTO.setUserId(userId); userDTO.setUserName(\u0026#34;hello world\u0026#34;); return userDTO; } }  举列子 （2）： 代表 /order/save,会被网关代理,而/order/findById 则不会。  @RestController @RequestMapping(\u0026#34;/order\u0026#34;) @SoulSpringCloudClient(path = \u0026#34;/order\u0026#34;) public class OrderController { @PostMapping(\u0026#34;/save\u0026#34;) @SoulSpringMvcClient(path = \u0026#34;/save\u0026#34;) public OrderDTO save(@RequestBody final OrderDTO orderDTO) { orderDTO.setName(\u0026#34;hello world save order\u0026#34;); return orderDTO; } @GetMapping(\u0026#34;/findById\u0026#34;) public OrderDTO findById(@RequestParam(\u0026#34;id\u0026#34;) final String id) { OrderDTO orderDTO = new OrderDTO(); orderDTO.setId(id); orderDTO.setName(\u0026#34;hello world findById\u0026#34;); return orderDTO; } }  启动你的服务，如果输出以下日志: http client register success, 证明你的接口已经被注册到soul网关。  插件设置  在 soul-admin 插件管理中，把 springCloud插件设置为开启。  用户请求   说白了，你之前怎么请求就怎么请求，没有很大的变动，变动的地方有2点。\n  第一点，你之前请求的域名是你自己的服务，现在要换成网关的域名 （这个你听的懂？）\n  第二点，soul网关需要有一个路由前缀，这个路由前缀就是你接入项目进行配置 contextPath ,如果熟的话，可以自由在 soul-admin 中的 springCloud插件进行自由更改.\n  # 比如你有一个 order服务 它有一个接口，请求路径 http://localhost:8080/test/save # 现在就需要换成：http://localhost:9195/order/test/save # 其中 localhost:9195 为网关的ip端口，默认端口是9195 ，/order 是你接入网关配置的 contextPath # 其他参数，请求方式不变。 # 我讲到这里还不懂？ 请加群问吧  然后你就可以进行访问了，如此的方便与简单。  "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/plugin-springcloud/",
	"title": "springcloud插件",
	"tags": [],
	"description": "springcloud插件",
	"content": "说明  该插件是用来将http协议 转成 springCloud协议 的核心。  插件设置   在 soul-admin \u0026ndash;\u0026gt; 插件管理-\u0026gt; springCloud ,设置为开启。\n  插件需要配合依赖 starter 进行使用 ,具体请看: springCloud用户。\n  选择器和规则，请详细看 : 选择器规则。\n  详解   应用名称：就是你根据条件匹配以后，需要调用的你的具体的应用名称。\n  soul会从springCloud的注册中心上面，根据应用名称获取对应的服务真实ip地址，发起http代理调用。\n  "
},
{
	"uri": "http://blog.valjean.cn/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/plugin-waf/",
	"title": "waf插件",
	"tags": [],
	"description": "waf插件",
	"content": "说明  waf插件，是网关的用来对流量实现防火墙功能的核心实现。  插件设置   在 soul-admin \u0026ndash;\u0026gt; 插件管理-\u0026gt; waf 设置为开启。\n  如果用户不想使用此功能，请在admin后台停用此插件。\n  插件编辑里面新增配置模式。\n  {\u0026#34;model\u0026#34;:\u0026#34;black\u0026#34;} # 默认为黑名单模式，设置值为 mixed 则为混合模式，下面会专门进行讲解 插件使用  在网关的 pom.xml 文件中添加 waf 的支持。  \u0026lt;!-- soul waf plugin start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-waf\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- soul waf plugin end--\u0026gt;   选择器和规则，请详细看 : 选择器规则\n  当 module 设置为 black 模式的时候, 只有匹配的流量才会执行拒绝策略，不匹配的，直接会跳过。\n  当 module 设置为 mixed 模式的时候，所有的流量都会通过 waf插件，针对不同的匹配流量，用户可以设置是 拒绝，还是通过。\n    场景   waf插件也是soul的前置插件，主要用来拦截非法请求，或者异常请求，并且给与相关的拒绝策略。\n  当你发现有大的攻击的适合，你可以根据ip或者host来进行匹配，拦截掉非法的ip与host，设置reject策略。\n  关于如何确定 ip 与 host 值，请看ip与host\n  "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/plugin-websocket/",
	"title": "websocket支持",
	"tags": [],
	"description": "websocket支持",
	"content": "说明   soul网关是支持 websocket的代理。\n  websocket支持中，使用了divide插件。\n  插件设置   在 soul-admin \u0026ndash;\u0026gt; 插件管理 \u0026ndash;\u0026gt; divide,设置为开启。\n  在网关的 pom.xml 文件中新增依赖\n  \u0026lt;!--if you use http proxy start this--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-divide\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-plugin-httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 请求路径  使用soul代理websocket的时候，其请求路径为（列子）: ws://localhost:9195/?module=ws\u0026amp;method=/websocket\u0026amp;rpcType=websocket。  参数详解: 1.localhost:8080 是soul启动的ip和端口。 2.module（必填）:值是你用来匹配selector的关键 3.method （参数）: 你的 websocket路径，同时也用做匹配rule 4.rpcType ：websocket 必填，且必须为websocket  在 divide插件中选择器新增一条配置 ，如下   在这一条选择器下新增一条 规则 ：    总结 ，这个时候注意看你的路径 ws://localhost:9195/?module=ws\u0026amp;method=/websocket\u0026amp;rpcType=websocket。\n它就会被你新增的选择器规则匹配，然后 代理的的真实websocket地址为 : 127.0.0.1:8080/websocket,这样soul就进行的websocket的代理。\n你就可以进行和websocket服务进行通信了,就是这么简单。\n  最后再说一句，module，method 命名和值，你完全可以自己来决定，我的只是列子，只要选择器 和规则能够匹配就行。\n  "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/user-datasync/",
	"title": "使用不同的数据同步策略",
	"tags": [],
	"description": "使用不同的数据同步策略",
	"content": "说明   数据同步是指将 soul-admin 配置的数据，同步到 soul 集群中的JVM内存里面，是网关高性能的关键。\n  实现原理，请看： 数据同步。\n  文中所说的网关，是指你搭建的网关环境，请看：搭建环境。\n  websocket同步（默认方式，推荐）   网关配置（记得重启）\n 首先在 pom.xml 文件中 引入以下依赖：    \u0026lt;!--soul data sync start use websocket--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-sync-data-websocket\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  在 springboot的 yml 文件中进行如下配置:  soul : sync: websocket : urls: ws://localhost:9095/websocket #urls:是指 soul-admin的地址，如果有多个，请使用（,）分割.   soul-admin 配置, 默认是开启 websocket 同步的，如果您想关闭，请指定soul.sync.websocket.enabled=false\n  当建立连接以后会全量获取一次数据，以后的数据都是增量的更新与新增，性能好。\n  支持断线重连 （默认30秒）。\n  zookeeper同步   网关配置（记得重启）\n 首先在 pom.xml 文件中 引入以下依赖：    \u0026lt;!--soul data sync start use zookeeper--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-sync-data-zookeeper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  在 springboot的 yml 文件中进行如下配置:  soul : sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000 #url: 配置成你的zk地址，集群环境请使用（,）分隔  soul-admin 配置, 或在 soul-admin 启动参数中设置 --soul.sync.zookeeper.url='你的地址' ,然后重启服务。  soul: sync: zookeeper: url: localhost:2181 sessionTimeout: 5000 connectionTimeout: 2000  使用zookeeper同步机制也是非常好的,时效性也高，我们生产环境使用的就是这个，但是也要处理zk环境不稳定，集群脑裂等问题.  http长轮询同步   网关配置（记得重启）\n 首先在 pom.xml 文件中 引入以下依赖：    \u0026lt;!--soul data sync start use zookeeper--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-sync-data-http\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  在 springboot的 yml 文件中进行如下配置:  soul : sync: http: url: http://localhost:9095 #url: 配置成你的 soul-admin的 ip与端口地址，多个admin集群环境请使用（,）分隔。  soul-admin 配置, 默认是开启 http 同步的，如果您想关闭，请指定soul.sync.http.enabled=false  soul: sync: http: refresh-interval: 5m # 默认5min刷新一次本地缓存 enabled: true # 默认启用http同步策略   http长轮询使得网关很轻量，时效性略低。\n  其根据分组key来拉取，如果数据量过大，过多，会有一定的影响。 什么意思呢？就是一个组下面的一个小地方更改，会拉取整个的组数据。\n  nacos同步   网关配置（记得重启）\n 首先在 pom.xml 文件中 引入以下依赖：    \u0026lt;!--soul data sync start use zookeeper--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-sync-data-nacos\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  在 springboot的 yml 文件中进行如下配置:  soul : sync: nacos: url: localhost:8848 namespace: 1c10d748-af86-43b9-8265-75f487d20c6c acm: enabled: false endpoint: acm.aliyun.com namespace: accessKey: secretKey: #url: 配置成你的nacos地址，集群环境请使用（,）分隔。 # 其他参数配置，请参考naocs官网。  soul-admin 配置, 或在 soul-admin 启动参数中使用 -- 的方式一个一个传值。  soul : sync: nacos: url: localhost:8848 namespace: 1c10d748-af86-43b9-8265-75f487d20c6c acm: enabled: false endpoint: acm.aliyun.com namespace: accessKey: secretKey: "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/metadata/",
	"title": "元数据概念设计",
	"tags": [],
	"description": "元数据概念设计",
	"content": "说明  本篇主要讲解在soul网关中元数据的概念，设计，以及如何对接。  技术方案   在数据库中，新增了一张表，然后通过数据同步的方案，会把这张表的数据同步到网关JVM内存。\n  表结构如下:\n  CREATE TABLE IF NOT EXISTS `meta_data` ( `id` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'id', `app_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '应用名称', `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '路径,不能重复', `path_desc` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '路径描述', `rpc_type` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL COMMENT 'rpc类型', `service_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '服务名称', `method_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '方法名称', `parameter_types` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT '参数类型 多给参数类型 逗号隔开', `rpc_ext` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL COMMENT 'rpc的扩展信息，json格式', `date_created` datetime(0) NOT NULL COMMENT '创建时间', `date_updated` datetime(0) NOT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT '更新时间', `enabled` tinyint(4) NOT NULL DEFAULT 0 COMMENT '启用状态', PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = Dynamic;   元数据设计，目前最主要的是对dubbo的泛化调用上进行使用。\n  我重点讲一下 path 字段，在请求网关的时候，会根据你的path字段来匹配到一条数据，然后进行后续的流程\n  重点讲一下 rcp_ext字段,如果是dubbo类型的服务接口，如果服务接口设置了 group,version字段的时候，会存在这个字段.\n dubbo 类型 字段结构是 如果，那么存储的就是json格式的字符串..   public static class RpcExt { private String group; private String version; private String loadbalance; private Integer retries; private Integer timeout; private String url; }   元数据存储   每个dubbo接口方法，对应一条元数据。\n  springcloud协议，只会存储一条数据， path为 /contextPath/**。\n  http服务，则不会有任何数据。\n  "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/admin/",
	"title": "启动admin",
	"tags": [],
	"description": "启动admin",
	"content": "说明   soul-admin 使用了mysql数据库,启动前请确保你正确安装了mysql.\n  soul-admin 是一个springboot的jar包,启动方式,可以直接 java -jar soul-admin.jar ,当然如果您也可以根据脚本来指定相关的jvm参数.\n  soul-admin 会自动创建数据库，以及表结构，并初始化默认数据.\n  服务端启动  拉取jar包，并启动  \u0026gt; wget https://yu199195.github.io/jar/soul-admin.jar \u0026gt; java -jar soul-admin.jar --spring.datasource.url=\u0026quot;jdbc:mysql://你的url:3306/soul?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;zeroDateTimeBehavior=CONVERT_TO_NULL\u0026amp;failOverReadOnly=false\u0026amp;autoReconnect=true\u0026amp;useSSL=false\u0026quot; --spring.datasource.username='you username' --spring.datasource.password='you password'  数据库无访问密码,将 \u0026ndash;spring.datasource.password=\u0026lsquo;you password\u0026rsquo; 去掉即可  \u0026gt; java -jar soul-admin.jar --spring.datasource.url=\u0026quot;jdbc:mysql://你的url:3306/soul?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;zerodatetimebehavior=CONVERT_TO_NULL\u0026amp;failOverReadOnly=false\u0026amp;autoReconnect=true\u0026amp;useSSL=false\u0026quot; --spring.datasource.username='you username'  遇到如下错误,将 zerodatetimebehavior=CONVERT_TO_NULL 去掉即可  java.sql.SQLException: The connection property \u0026#39;zeroDateTimeBehavior\u0026#39; only accepts values of the form: \u0026#39;exception\u0026#39;, \u0026#39;round\u0026#39; or \u0026#39;convertToNull\u0026#39;. The value \u0026#39;CONVERT_TO_NULL\u0026#39; is not in this set.   访问 http://localhost:9095/index.html  默认的用户名： admin 密码:123456\n  如果已经使用 soul, 并且未修改默认秘钥,明文密码 123456 对应的 密文是 jHcpKkiDbbQh7W7hh8yQSA==\n  本地启动   拉取代码\n\u0026gt; git clone https://github.com/Dromara/soul.git \u0026gt; cd soul \u0026gt; mvn -DskipTests clean install -U   使用你的idea 打开项目.\n  修改yml文件，修改你的数据库注意环境,默认使用 application-local.yml.\n  server: port: 9095 address: 0.0.0.0 spring: thymeleaf: cache: true encoding: utf-8 enabled: true prefix: classpath:/static/ suffix: .html datasource: url: jdbc:mysql://你的地址:3306/soul-open?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;zeroDateTimeBehavior=CONVERT_TO_NULL\u0026amp;failOverReadOnly=false\u0026amp;autoReconnect=true\u0026amp;useSSL=false username: 你的用户名 password: 你的密码 dbcp2: driver-class-name: com.mysql.jdbc.Driver mybatis: config-location: classpath:/mybatis/mybatis-config.xml mapper-locations: classpath:/mappers/*.xml   启动 org.dromara.soul.admin.SoulAdminApplication.\n  访问 http://localhost:9095/index.html 默认的用户名和密码为 admin 123456\n  "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/dev-client/",
	"title": "多语言http客户端",
	"tags": [],
	"description": "多语言http客户端",
	"content": "说明   本文主要讲解其他语言的http服务如何接入网关。\n  如何自定义开发 soul-http-client\n  自定义开发   请求方式: POST\n  请求路径\n http://soul-admin/soul-client/springmvc-register soul-admin, 表示为 admin的 ip + port    请求参数\n  soul网关默认的需要参数,通过body里面传，json类型。\n  { \u0026#34;appName\u0026#34;: \u0026#34;xxx\u0026#34;, //应用名称 必填 \u0026#34;context\u0026#34;: \u0026#34;/xxx\u0026#34;, //请求前缀 必填 \u0026#34;path\u0026#34;: \u0026#34;xxx\u0026#34;, //路径需要唯一 必填 \u0026#34;rpcType\u0026#34;: \u0026#34;http\u0026#34;, //rpc类型 必填 \u0026#34;host\u0026#34;: \u0026#34;xxx\u0026#34;, //服务host 必填 \u0026#34;port\u0026#34;: xxx, //服务端口 必填 \u0026#34;ruleName\u0026#34;: \u0026#34;xxx\u0026#34;, //可以同path一样 必填 \u0026#34;enabled\u0026#34;: \u0026#34;true\u0026#34; } "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/dev-plugin/",
	"title": "插件扩展",
	"tags": [],
	"description": "插件扩展",
	"content": "说明   插件是 soul 网关的核心执行者，每个插件在开启的情况下，都会对匹配的流量，进行自己的处理。\n  在soul 网关里面，插件其实分为2 类：\n  一类是单一职责的调用链，不能对流量进行自定义的筛选。\n  另一类，能对匹配的流量，执行自己的职责调用链。\n    用户可以参考 soul-plugin 模块，新增自己的插件处理，如果有好的公用插件，请把代码提交上来。\n  单一职责插件  引入如下依赖 :   \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-plugin-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  用户新增一个类 A,直接实现 org.dromara.soul.plugin.api.SoulPlugin  public interface SoulPlugin { /** * Process the Web request and (optionally) delegate to the next * {@code WebFilter} through the given {@link SoulPluginChain}. * * @param exchange the current server exchange * @param chain provides a way to delegate to the next filter * @return {@code Mono\u0026lt;Void\u0026gt;} to indicate when request processing is complete */ Mono\u0026lt;Void\u0026gt; execute(ServerWebExchange exchange, SoulPluginChain chain); /** * return plugin order . * This attribute To determine the plugin execution order in the same type plugin. * * @return int order */ int getOrder(); /** * acquire plugin name. * this is plugin name define you must Provide the right name. * if you impl AbstractSoulPlugin this attribute not use. * * @return plugin name. */ default String named() { return \u0026#34;\u0026#34;; } /** * plugin is execute. * if return true this plugin can not execute. * * @param exchange the current server exchange * @return default false. */ default Boolean skip(ServerWebExchange exchange) { return false; } }   接口方法详细说明\n  execute() 方法为核心的执行方法，用户可以在里面自由的实现自己想要的功能。\n  getOrder() 指定插件的排序。\n  named() 指定插件的名称。\n  skip() 在特定的条件下，该插件是否被跳过。\n    注册成Spring的bean，参考如下,或者直接在实现类上加 @Component 注解。\n  @Bean public SoulPlugin a() { return new A(); } 匹配流量处理插件  引入如下依赖 :  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-plugin-base\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   新增一个类A，继承 org.dromara.soul.plugin.base.AbstractSoulPlugin\n  以下是参考 ：\n  /** * This is your custom plugin. * He is running in after before plugin, implement your own functionality. * extends AbstractSoulPlugin so you must user soul-admin And add related plug-in development. * * @author xiaoyu(Myth) */ public class CustomPlugin extends AbstractSoulPlugin { /** * return plugin order . * The same plugin he executes in the same order. * * @return int */ @Override public int getOrder() { return 0; } /** * acquire plugin name. * return you custom plugin name. * It must be the same name as the plug-in you added in the admin background. * * @return plugin name. */ @Override public String named() { return \u0026#34;soul\u0026#34;; } /** * plugin is execute. * Do I need to skip. * if you need skip return true. * * @param exchange the current server exchange * @return default false. */ @Override public Boolean skip(final ServerWebExchange exchange) { return false; } @Override protected Mono\u0026lt;Void\u0026gt; doExecute(ServerWebExchange exchange, SoulPluginChain chain, SelectorZkDTO selector, RuleZkDTO rule) { LOGGER.debug(\u0026#34;.......... function plugin start..............\u0026#34;); /* * Processing after your selector matches the rule. * rule.getHandle() is you Customize the json string to be processed. * for this example. * Convert your custom json string pass to an entity class. */ final String ruleHandle = rule.getHandle(); final Test test = GsonUtils.getInstance().fromJson(ruleHandle, Test.class); /* * Then do your own business processing. * The last execution chain.execute(exchange). * Let it continue on the chain until the end. */ System.out.println(test.toString()); return chain.execute(exchange); } }   详细讲解 ：\n  继承该类的插件，插件会进行选择器规则匹配，那如何来设置呢？\n  首先在 soul-admin 后台 \u0026ndash;\u0026gt;插件管理中，新增一个插件，注意 名称与 你自定义插件的 named（） 方法要一致。\n  重新登陆 soul-admin 后台 ，你会发现在插件列表就多了一个你刚新增的插件，你就可以进行选择器规则匹配\n  在规则中，有个 handler 字段，是你自定义处理数据，在 doExecute() 方法中，通过  final String ruleHandle = rule.getHandle(); 获取，然后进行你的操作。\n    注册成Spring的bean，参考如下,或者直接在实现类上加 @Component 注解。\n  @Bean public SoulPlugin a() { return new A(); } 订阅你的插件数据，进行自定义的处理  新增一个类A，实现 org.dromara.soul.plugin.base.handler.PluginDataHandler  public interface PluginDataHandler { /** * Handler plugin. * * @param pluginData the plugin data */ default void handlerPlugin(PluginData pluginData) { } /** * Remove plugin. * * @param pluginData the plugin data */ default void removePlugin(PluginData pluginData) { } /** * Handler selector. * * @param selectorData the selector data */ default void handlerSelector(SelectorData selectorData) { } /** * Remove selector. * * @param selectorData the selector data */ default void removeSelector(SelectorData selectorData) { } /** * Handler rule. * * @param ruleData the rule data */ default void handlerRule(RuleData ruleData) { } /** * Remove rule. * * @param ruleData the rule data */ default void removeRule(RuleData ruleData) { } /** * Plugin named string. * * @return the string */ String pluginNamed(); }   注意 pluginNamed() 要和你自定义的插件名称相同。\n  注册成Spring的bean，参考如下,或者直接在实现类上加 @Component 注解。\n  @Bean public PluginDataHandler a() { return new A(); } "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/datasync/",
	"title": "数据同步设计",
	"tags": [],
	"description": "数据同步设计",
	"content": "说明  本篇主要讲解数据库同步的三种方式，以及原理  前言 网关是流量请求的入口，在微服务架构中承担了非常重要的角色，网关高可用的重要性不言而喻。在使用网关的过程中，为了满足业务诉求，经常需要变更配置，比如流控规则、路由规则等等。因此，网关动态配置是保障网关高可用的重要因素。那么，Soul 网关又是如何支持动态配置的呢?\n使用过 Soul 的同学都知道，Soul 的插件全都是热插拔的，并且所有插件的选择器、规则都是动态配置，立即生效，不需要重启服务。但是我们在使用 Soul 网关过程中，用户也反馈了不少问题\n 依赖 zookeeper，这让使用 etcd、consul、nacos 注册中心的用户很是困扰 依赖 redis、influxdb，我还没有使用限流插件、监控插件，为什么需要这些  因此，我们对 Soul 进行了局部重构，历时两个月的版本迭代，我们发布了 2.0 版本\n 数据同步方式移除了对 zookeeper 的强依赖，新增 http 长轮询 以及 websocket 限流插件与监控插件实现真正的动态配置，由之前的 yml 配置，改为 admin 后台用户动态配置  1.可能有人会问我，配置同步为什么不使用配置中心呢？ 答：首先，引入配置中心，会增加很多额外的成本，不管是运维，而且会让 Soul 变得很重；另外，使用配置中心，数据格式不可控，不便于 soul-admin 进行配置管理。\n2.可能还有人会问？动态配置更新？每次我查数据库，或者redis不就行了吗？拿到的就是最新的，哪里那么多事情呢？ 答：soul作为网关，为了提供更高的响应速度，所有的配置都缓存在JVM的Hashmap中，每次请求都走的本地缓存，速度非常快。所以本文也可以理解为分布式环境中，内存同步的三种方式。\n原理分析 先来张高清无码图，下图展示了 Soul 数据同步的流程，Soul 网关在启动时，会从从配置服务同步配置数据，并且支持推拉模式获取配置变更信息，并且更新本地缓存。而管理员在管理后台，变更用户、规则、插件、流量配置，通过推拉模式将变更信息同步给 Soul 网关，具体是 push 模式，还是 pull 模式取决于配置。关于配置同步模块，其实是一个简版的配置中心。 在 1.x 版本中，配置服务依赖 zookeeper 实现，管理后台将变更信息 push 给网关。而 2.x 版本支持 webosocket、http、zookeeper，通过 soul.sync.strategy 指定对应的同步策略，默认使用 http 长轮询同步策略，可以做到秒级数据同步。但是，有一点需要注意的是，soul-web 和 soul-admin 必须使用相同的同步机制。\n如下图所示，soul-admin 在用户发生配置变更之后，会通过 EventPublisher 发出配置变更通知，由 EventDispatcher 处理该变更通知，然后根据配置的同步策略(http、weboscket、zookeeper)，将配置发送给对应的事件处理器\n 如果是 websocket 同步策略，则将变更后的数据主动推送给 soul-web，并且在网关层，会有对应的 WebsocketCacheHandler 处理器处理来处 admin 的数据推送 如果是 zookeeper 同步策略，将变更数据更新到 zookeeper，而 ZookeeperSyncCache 会监听到 zookeeper 的数据变更，并予以处理 如果是 http 同步策略，soul-web 主动发起长轮询请求，默认有 90s 超时时间，如果 soul-admin 没有数据变更，则会阻塞 http 请求，如果有数据发生变更则响应变更的数据信息，如果超过 60s 仍然没有数据变更则响应空数据，网关层接到响应后，继续发起 http 请求，反复同样的请求   zookeeper同步 基于 zookeeper 的同步原理很简单，主要是依赖 zookeeper 的 watch 机制，soul-web 会监听配置的节点，soul-admin 在启动的时候，会将数据全量写入 zookeeper，后续数据发生变更时，会增量更新 zookeeper 的节点，与此同时，soul-web 会监听配置信息的节点，一旦有信息变更时，会更新本地缓存。\nsoul 将配置信息写到zookeeper节点，是通过精细设计的。\nwebsocket同步 websocket 和 zookeeper 机制有点类似，将网关与 admin 建立好 websocket 连接时，admin 会推送一次全量数据，后续如果配置数据发生变更，则将增量数据通过 websocket 主动推送给 soul-web\n使用websocket同步的时候，特别要注意断线重连，也叫保持心跳。soul使用java-websocket 这个第三方库来进行websocket连接。\npublic class WebsocketSyncCache extends WebsocketCacheHandler { /** * The Client. */ private WebSocketClient client; public WebsocketSyncCache(final SoulConfig.WebsocketConfig websocketConfig) { ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1, SoulThreadFactory.create(\u0026quot;websocket-connect\u0026quot;, true)); client = new WebSocketClient(new URI(websocketConfig.getUrl())) { @Override public void onOpen(final ServerHandshake serverHandshake) { //.... } @Override public void onMessage(final String result) { //.... } }; //进行连接 client.connectBlocking(); //使用调度线程池进行断线重连，30秒进行一次 executor.scheduleAtFixedRate(() -\u0026gt; { if (client != null \u0026amp;\u0026amp; client.isClosed()) { client.reconnectBlocking(); } }, 10, 30, TimeUnit.SECONDS); } http长轮询 zookeeper、websocket 数据同步的机制比较简单，而 http 同步会相对复杂一些。Soul 借鉴了 Apollo、Nacos 的设计思想，取决精华，自己实现了 http 长轮询数据同步功能。注意，这里并非传统的 ajax 长轮询！\nhttp 长轮询机制如上所示，soul-web 网关请求 admin 的配置服务，读取超时时间为 90s，意味着网关层请求配置服务最多会等待 90s，这样便于 admin 配置服务及时响应变更数据，从而实现准实时推送。\nhttp 请求到达 sou-admin 之后，并非立马响应数据，而是利用 Servlet3.0 的异步机制，异步响应数据。首先，将长轮询请求任务 LongPollingClient 扔到 BlocingQueue 中，并且开启调度任务，60s 后执行，这样做的目的是 60s 后将该长轮询请求移除队列，即便是这段时间内没有发生配置数据变更。因为即便是没有配置变更，也得让网关知道，总不能让其干等吧，而且网关请求配置服务时，也有 90s 的超时时间。\npublic void doLongPolling(final HttpServletRequest request, final HttpServletResponse response) { // 因为soul-web可能未收到某个配置变更的通知，因此MD5值可能不一致，则立即响应 List\u0026lt;ConfigGroupEnum\u0026gt; changedGroup = compareMD5(request); String clientIp = getRemoteIp(request); if (CollectionUtils.isNotEmpty(changedGroup)) { this.generateResponse(response, changedGroup); return; } // Servlet3.0异步响应http请求 final AsyncContext asyncContext = request.startAsync(); asyncContext.setTimeout(0L); scheduler.execute(new LongPollingClient(asyncContext, clientIp, 60)); } class LongPollingClient implements Runnable { LongPollingClient(final AsyncContext ac, final String ip, final long timeoutTime) { // 省略...... } @Override public void run() { // 加入定时任务，如果60s之内没有配置变更，则60s后执行，响应http请求 this.asyncTimeoutFuture = scheduler.schedule(() -\u0026gt; { // clients是阻塞队列，保存了来处soul-web的请求信息 clients.remove(LongPollingClient.this); List\u0026lt;ConfigGroupEnum\u0026gt; changedGroups = HttpLongPollingDataChangedListener.compareMD5((HttpServletRequest) asyncContext.getRequest()); sendResponse(changedGroups); }, timeoutTime, TimeUnit.MILLISECONDS); // clients.add(this); } } 如果这段时间内，管理员变更了配置数据，此时，会挨个移除队列中的长轮询请求，并响应数据，告知是哪个 Group 的数据发生了变更（我们将插件、规则、流量配置、用户配置数据分成不同的组）。网关收到响应信息之后，只知道是哪个 Group 发生了配置变更，还需要再次请求该 Group 的配置数据。有人会问，为什么不是直接将变更的数据写出？我们在开发的时候，也深入讨论过该问题，因为 http 长轮询机制只能保证准实时，如果在网关层处理不及时，或者管理员频繁更新配置，很有可能便错过了某个配置变更的推送，安全起见，我们只告知某个 Group 信息发生了变更。\n// soul-admin发生了配置变更，挨个将队列中的请求移除，并予以响应 class DataChangeTask implements Runnable { DataChangeTask(final ConfigGroupEnum groupKey) { this.groupKey = groupKey; } @Override public void run() { try { for (Iterator\u0026lt;LongPollingClient\u0026gt; iter = clients.iterator(); iter.hasNext(); ) { LongPollingClient client = iter.next(); iter.remove(); client.sendResponse(Collections.singletonList(groupKey)); } } catch (Throwable e) { LOGGER.error(\u0026quot;data change error.\u0026quot;, e); } } } 当 soul-web 网关层接收到 http 响应信息之后，拉取变更信息（如果有变更的话），然后再次请求 soul-admin 的配置服务，如此反复循环。\n仓库地址 github: https://github.com/Dromara/soul\ngitee: https://gitee.com/shuaiqiyu/soul\n项目主页上还有视频教程，有需要的朋友可以去观看。\n最后 此文介绍了soul作为一个高可用的微服务网关，为了优化响应速度，在对配置规则选择器器数据进行本地缓存的三种方式，学了此文，我相信你对现在比较流行的配置中心有了一定的了解，看他们的代码也许会变得容易，我相信你也可以自己写一个分布式配置中心出来。3.0版本已经在规划中，肯定会给大家带来惊喜。\n"
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/db/",
	"title": "数据库设计",
	"tags": [],
	"description": "数据库设计",
	"content": "  插件采用数据库设计，来存储插件，选择器，规则配置数据，以及对应关系。\n  数据库表UML类图:\n    设计详解:\n  一个插件对应多个选择器，一个选择器对应多个规则。\n  一个选择器对应多个匹配条件，一个规则对应多个匹配条件。\n  每个规则在对应插件下，不同的处理表现为handle字段，这个一个不同处理的json字符串。具体的可以在admin使用过程中进行查看。\n    "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/dev-file/",
	"title": "文件上传下载",
	"tags": [],
	"description": "文件上传下载",
	"content": "说明  本文主要介绍soul的文件上传下载的支持。  文件上传   默认限制文件大小为 10M。\n  如果想修改,在启动服务的时候，使用--file.size = 30 ,为int 类型。\n  你之前怎么上传文件，还是怎么上传。\n  文件下载  soul支持流的方式进行下载，你之前的接口怎么写的，还是怎么写，根本不需要变.  "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/dev-iphost/",
	"title": "正确获取Ip与host",
	"tags": [],
	"description": "正确获取Ip与host",
	"content": "说明   本文是说明，如果网关前面有一层nginx 的时候，如何获取正确的ip与端口。\n  获取正确的之后，在插件以及选择器中，可以根据 ip，与host来进行匹配。\n  默认实现   在soul网关自带实现为:org.dromara.soul.web.forwarde.ForwardedRemoteAddressResolver。\n  它需要你在 nginx 设置 X-Forwarded-For,以便来或者正确的 ip 与 host。\n  扩展实现  新增一个类A，实现org.dromara.soul.plugin.api.RemoteAddressResolver  public interface RemoteAddressResolver { /** * Resolve inet socket address. * * @param exchange the exchange * @return the inet socket address */ default InetSocketAddress resolve(ServerWebExchange exchange) { return exchange.getRequest().getRemoteAddress(); } }  把你新增的实现类注册成为spring的bean,如下  @Bean public SignService a() { return new A } "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/setup/",
	"title": "环境搭建",
	"tags": [],
	"description": "环境搭建",
	"content": "说明   soul 2.2.0以后都是基于插件化可插拔的思想，本文是说明,如何基于soul搭建属于你自己网关。\n  请确保你的机器安装了JDK 1.8+ , Mysql 5.0 + 。\n  启动 Soul-Admin  下载soul-admin.jar包，并启动.  \u0026gt; wget https://yu199195.github.io/jar/soul-admin.jar \u0026gt; java -jar soul-admin.jar --spring.datasource.url=\u0026#34;jdbc:mysql://你的url:3306/soul?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;useSSL=false\u0026#34;  --spring.datasource.username=\u0026#39;you username\u0026#39; --spring.datasource.password=\u0026#39;you password\u0026#39;  访问 http://localhost:9095/index.html  默认的用户名： admin 密码:123456。  搭建自己的网关（推荐）   首先你新建一个空的springboot项目，可以参考 soul-bootstrap. 也可以在spring官网:[https://spring.io/quickstart]\n  引入如下jar包：\n  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-webflux\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.2-RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.2-RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--soul gateway start--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-gateway\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--soul data sync start use websocket--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.dromara\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;soul-spring-boot-starter-sync-data-websocket\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  在你的 application.yaml 文件中加上如下配置：  spring: main: allow-bean-definition-overriding: true management: health: defaults: enabled: false soul : sync: websocket : urls: ws://localhost:9095/websocket //设置成你的soul-admin地址 swagger: enable: true  你的项目环境搭建完成,启动你的项目。  "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/dev-thread/",
	"title": "线程模型",
	"tags": [],
	"description": "线程模型",
	"content": "说明  本文主要介绍soul的线程模型,以及各种场景的使用。  io与work线程  soul内置依赖 spring-webflux 而其底层是使用的netty。这一块只要是使用的netty线程模型。  业务线程   默认使用调度线程来执行。\n  默认使用固定的线程池来执行，其线程数为 cpu * 2 + 1。\n  切换类型   reactor.core.scheduler.Schedulers。\n  可以使用 -Dsoul.scheduler.type=fixed 这个是默认。 设置其他的值 就会使用弹性线程池来执行,Schedulers.elastic()。\n  可以使用 -Dsoul.work.threads = xx 来指定线程数量，默认为 cpu * 2 + 1 ,最小为16个线程。\n  "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/dev-sign/",
	"title": "自定义sign插件检验",
	"tags": [],
	"description": "自定义sign插件检验",
	"content": "说明  用户可以自定义签名认证算法来实现验证。  扩展   默认的实现为 org.dromara.soul.plugin.sign.service.DefaultSignService。\n  新增一个类 A 实现 org.dromara.soul.plugin.api.SignService。\n  public interface SignService { /** * Sign verify pair. * * @param exchange the exchange * @return the pair */ Pair\u0026lt;Boolean, String\u0026gt; signVerify(ServerWebExchange exchange); }   Pair中返回true,表示验证通过，为false的时候，会把String中的信息输出到前端。\n  把你新增的实现类注册成为spring的bean,如下\n  @Bean public SignService a() { return new A } "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/dev-result/",
	"title": "自定义网关返回数据格式",
	"tags": [],
	"description": "自定义网关返回数据格式",
	"content": "说明   本文是说明,基于soul网关，返回自定义的数据个数。\n  网关需要统一的返回格式,而每个公司都有自己定义的一套，所以需要对次进行扩展。\n  默认实现   默认的实现为 org.dromara.soul.plugin.api.result.DefaultSoulResult\n  返回的数据格式如下：\n  public class SoulDefaultEntity implements Serializable { private static final long serialVersionUID = -2792556188993845048L; private Integer code; private String message; private Object data; }  返回的json 格式如下:  { \u0026#34;code\u0026#34;: -100, //返回码, \u0026#34;message\u0026#34;: \u0026#34;您的参数错误,请检查相关文档!\u0026#34;, //提示字段 \u0026#34;data\u0026#34;: null // 具体的数据 } 扩展  新增一个类 A 实现 org.dromara.soul.plugin.api.result.SoulResult  public interface SoulResult\u0026lt;T\u0026gt; { /** * Success t. * * @param code the code * @param message the message * @param object the object * @return the t */ T success(int code, String message, Object object); /** * Error t. * * @param code the code * @param message the message * @param object the object * @return the t */ T error(int code, String message, Object object); }   其他 泛型 T 为你自定义的数据格式，返回它就好\n  把你新增的实现类注册成为spring的bean,如下\n  @Bean public SoulResult a() { return new A(); } "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/selector/",
	"title": "选择器规则详解",
	"tags": [],
	"description": "选择器规则详解",
	"content": "说明   选择器和规则是soul网关中最灵魂的东西。掌握好它，你可以对任何流量进行管理。\n  本篇主要详解soul网关中，选择器与规则的概念，以及如何使用。\n  大体理解   一个插件有多个选择器，一个选择器对应多种规则。选择器相当于是对流量的第一次筛选，规则就是最终的筛选。\n  我们想象一下，在一个插件里面，我们是不是希望根据我们的配置，达到满足条件的流量，我们插件才去执行它？\n  选择器和规则就是为了让流量在满足特定的条件下，才去执行我们想要的，这个你首先头脑要点数。\n  数据结构可以参考之前的 数据库设计\n  选择器   选择器详解：\n 名称：为你的选择器起一个容易分辨的名字 类型：custom flow 是自定义流量。full flow 是全流量。自定义流量就是请求会走你下面的匹配方式与条件。全流量则不走。 匹配方式：and 或者or 是指下面多个条件是按照and 还是or的方式来组合。 条件：  uri:是指你根据uri的方式来筛选流量，match的方式支持模糊匹配（/**） header:是指根据请求头里面的字段来筛选流量。 query: 是指根据uri的查询条件来进行筛选流量。 ip:是指根据你请求的真实ip，来筛选流量。 host:是指根据你请求的真实host，来筛选流量。 post:建议不要使用。 条件匹配:  match : 模糊匹配，建议和uri条件搭配，支持 restful风格的匹配。（/test/**） = : 前后值相等，才能匹配。 regEx : 正则匹配，表示前面一个值去匹配后面的正则表达式。 like ：字符串模糊匹配。     是否开启：打开才会生效 打印日志：打开的时候，当匹配上的时候，会打印匹配日志。 执行顺序：当多个选择器的时候，执行顺序小的优先执行。    上述图片中表示:当请求的uri前缀是 /test，并且header 头上 module 字段值为test 的时候，会转发到 1.1.1.1:8080 这个服务。\n  选择器建议 : 可以uri 条件， match 前缀 （/contextPath），进行第一道流量筛选。\n  规则   当流量经过选择器匹配成功之后，会进入规则来进行最终的流量匹配。\n  规则是对流量最终执行逻辑的确认。\n  规则详解：\n 名称：为你的规则起一个容易分辨的名字 匹配方式：and 或者or 是指下面多个条件是按照and 还是or。 条件：  uri:是指你根据uri的方式来筛选流量，match的方式支持模糊匹配（/**） header:是指根据请求头里面的字段来筛选流量。 query: 是指根据uri的查询条件来进行筛选流量。 ip:是指根据你请求的真实ip，来筛选流量。 host:是指根据你请求的真实host，来筛选流量。 post:建议不要使用。 条件匹配:  match : 模糊匹配，建议和uri条件搭配，支持 restful风格的匹配。（/test/**） = : 前后值相等，才能匹配。 regEx : 正则匹配，表示前面一个值去匹配后面的正则表达式。 like ：字符串模糊匹配。     是否开启：打开才会生效。 打印日志：打开的时候，当匹配上的时候，会打印匹配日志。 执行顺序：当多个选择器的时候，执行顺序小的优先执行。 处理：每个插件的规则处理不一样，具体的差有具体的处理，具体请查看每个对应插件的处理。    上图表示:当 uri 等于 /http/order/save 的时候该规则被匹配,就会执行该规则中，负载策略是 random\n  联合选择器,我们来表述一下 ：当一个 请求的 uri  为 /http/order/save, 会通过 random 的方式，转发到 1.1.1.1:8080。\n  规则建议: 可以uri 条件， match 最真实的uri路径，进行流量的最终筛选 。\n  条件详解   uri 匹配 （推荐）\n  uri匹配是根据你请求路径中的uri来进行匹配，在接入网关的时候，前端几乎不用做任何更改。\n  当使用 match 方式匹配时候，同 springmvc 模糊匹配原理相同。\n  在选择器中，推荐使用uri中的前缀来进行匹配，而在规则中，则使用具体路径来进行匹配。\n  该匹配方式的时候，在匹配字段名称可以任意填写，匹配字段值需要正确填写。\n    header 匹配\n header是根据你的http 请求头中的字段值来匹配。    query 匹配\n  这个是根据你的uri中的查询参数来进行匹配，比如 /test?a=1\u0026amp;\u0026amp;b=2 ，那么可以选择该匹配方式。\n  上述就可以新增一个条件，选取 query方式 , a = 1 。\n    ip匹配\n  这个是根据 http调用方的 ip来进行匹配。\n  尤其是在waf插件里面，如果发现一个ip地址有攻击，可以新增一条匹配条件，填上该ip，拒绝该ip的访问。\n  如果在soul前面使用了nginx代理，为了获取正确的ip，你可能要参考 dev-iphost\n    host匹配\n  这个是根据 http调用方的host来进行匹配。\n  尤其是在waf插件里面，如果发现一个host地址有攻击，可以新增一条匹配条件，填上该host，拒绝该host的访问。\n  如果在soul前面使用了nginx代理，为了获取正确的host，你可能要参考 dev-iphost\n    post匹配\n 不推荐使用。    "
},
{
	"uri": "http://blog.valjean.cn/soul/tmp_doc/config/",
	"title": "配置流程介绍",
	"tags": [],
	"description": "配置流程介绍",
	"content": "说明  本篇是对admin后台操作数据以后，同步到网关的流程介绍。  使用   用户可以在 soul-admin 后台任意修改数据，并马上同步到网关的jvm内存中。\n  同步soul的插件数据，选择器，规则数据，元数据，签名数据等等。\n  所有插件的选择器，规则都是动态配置，立即生效，不需要重启服务。\n  下面是数据流程图：   作用   用户所有的配置都可以动态的更新，任何修改不需要重启服务。\n  使用了本地缓存，在高并发的时候，提供高效的性能。\n  "
}]