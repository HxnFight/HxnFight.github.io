<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>源码学习 on Documentation for Hugo Learn Theme</title>
    <link>http://blog.valjean.cn/soul/src_learn/</link>
    <description>Recent content in 源码学习 on Documentation for Hugo Learn Theme</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Tue, 26 Jan 2021 16:05:11 +0800</lastBuildDate><atom:link href="http://blog.valjean.cn/soul/src_learn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>spring相关内容补充</title>
      <link>http://blog.valjean.cn/soul/src_learn/spring_learn/</link>
      <pubDate>Tue, 26 Jan 2021 16:05:44 +0800</pubDate>
      
      <guid>http://blog.valjean.cn/soul/src_learn/spring_learn/</guid>
      <description>spring 相关内容补充    ApplicationListener : baeldung tutor office-tutor , 自定义的实现可以通过实现特定类或者利用相关注解是实现 默认情况下是同步的，可以通过配置更改为异步执行. 这个功能是在单个项目内流转，数据也是在内部流转. 适用于业务在单个实例中
能全部解决的情况. 类似cmsweb这种项目. 分布式之类的项目需要考虑其他mq之类的方案.
 soul-admin中有自定义的ApplicationEvent事件,其他的soul-web、soul-client-springcloud、soul-client-springmvc soul-client-alibaba-dubbo soul-client-apache-dubbo 均为监控的spirng容器的特殊事件.
    InitializingBean InstantiationAwareBeanPostProcessor spring bean initial 文中介绍了spring springboot中各种各样的初始化bean的方式。 自己只是用到一部分，后续会尝试其他的方式
   tutor BeanPostProcessor 相关的实现太多，目前只是粗略了解一下。 idea 中查看类关系的uml蛮好使的，在生成的uml中，点击右键可以添加其他的相关类 只添加了相关的几个. spring 注入方式 构造函数注入、字段注入、set方法注入. 自己平时员工字段注入较多，其他的类型有空尝试一下
  bean liftcycle callback
 soul-admin 使用到的类有以下几个
  ApplicationContextAware contextaware spring上下文 将spring上下文保存下来，可以随时获取容器内bean的. soul中使用的有以下两个类
    ObjectProvider tutor office   EnumMap tutor 以enum作为key的map，简单了解</description>
    </item>
    
    <item>
      <title>Webflux</title>
      <link>http://blog.valjean.cn/soul/src_learn/webflux/</link>
      <pubDate>Mon, 18 Jan 2021 16:42:43 +0800</pubDate>
      
      <guid>http://blog.valjean.cn/soul/src_learn/webflux/</guid>
      <description>webflux  soul-bootstrap中实现高吞吐量的关键就在于webflux的异步非阻塞特性。在网上查了相关的资料， 有个大概的了解,后续会在项目中慢慢实践一下。
为什么会创建webflux  office docs 官网上给出了两点的解释. 使用相对少的线程数和硬件资源去处理并发,再个就是函数编程.  Part of the answer is the need for a non-blocking web stack to handle concurrency with a small number of threads and scale with fewer hardware resources.
 The other part of the answer is functional programming.
 其中关于阻塞请求和非阻塞请求，参考website docs
  阻塞请求
    非阻塞请求
    支持的模型1    Java 注解编程模型 这种编程模型，类似spring mvc,相对来说学习成本不高。</description>
    </item>
    
    <item>
      <title>soul plugin 调用链</title>
      <link>http://blog.valjean.cn/soul/src_learn/soul-chain/</link>
      <pubDate>Mon, 18 Jan 2021 16:42:43 +0800</pubDate>
      
      <guid>http://blog.valjean.cn/soul/src_learn/soul-chain/</guid>
      <description> 插件链初探  soul-bootstrap启动,相关初始化工作完毕之后，当外部发起一个请求到soul-bootstrap,其内部是如何进行过滤、筛选的. 此次拿divide插件来做简单分析。 SoulWebHandler是程序的一个入口点，目前soul代理的服务，都是通过http请求调用的。该类在初始化的时候，会获取到pom中配置的相关插件依赖创建的spring bean. 其handle方法会被触发执行，（这块应该是框架调用的，待确认）.随后会创建一个 DefaultSoulPluginChain 并发起插件链的调用。
   插件的分类  soul的插件有个基础接口SoulPlugin和一个实现了execute方法的 AbstractSoulPlugin. 其他的类型的插件，要么直接继承AbstractSoulPlugin 实现doExecute对 对插件进行扩展。 要么直接实现SoulPlugin。 下图是抽取一部分的plugin之间的关系。
   待补充    对webflux的了解，能看明白相关代码
  SoulWebHandler是怎么被拉起的
    </description>
    </item>
    
    <item>
      <title>tars summary</title>
      <link>http://blog.valjean.cn/soul/src_learn/summary/</link>
      <pubDate>Mon, 18 Jan 2021 16:42:43 +0800</pubDate>
      
      <guid>http://blog.valjean.cn/soul/src_learn/summary/</guid>
      <description>分享  tarscloud 由来    tars 简介 office website   office quick start
  配置应用, 这里基础概念很重要
   tars 基础概念 应用名：表示一组服务的集合 –&amp;gt; APP 服务名称：提供服务的进程名称 –&amp;gt; Server OBJ：提供具体服务的接口 –&amp;gt; Servant    环境搭建    搞明白tars-framework, tars-nodesd的不同
 framework: Tars 框架 Docker 制作脚本, 制作的 docker 包含了框架核心服务和 web 管理平台 tars: Tars 框架 Docker 制作脚本, 和 framework 比, 增加了 java, nodejs 等运行时支持, 即可以把 java, nodejs 服务发布到 docker 里面(docker 里面安装了 jdk, node, php 环境) nodes: 是正常的代码运行环境，包含基本的开发环境。</description>
    </item>
    
  </channel>
</rss>
